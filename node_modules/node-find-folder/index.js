'use strict';
var FF, _default, _filter, _options, _readDirFolderCache, convertTo_Obj, fs, getFolders, glob, ifExistInRoot, ignoreFilter, isDir, isFile, lodash, traversal_pattern, traverse_scope;

_options = void 0;

fs = require('fs');

glob = require('glob');

lodash = require('lodash');

isFile = require('is-file');

isDir = require('is-directory');

_default = {
  nottraversal: ['.git', 'node_modules'],
  ignore: []
};

convertTo_Obj = function(filter) {
  var obj;
  obj = {};
  if (lodash.isArray(filter)) {
    lodash.forEach(filter, function(_item, _index, _array) {
      return obj[_item] = _index;
    });
  } else if (lodash.isString(filter)) {
    obj[filter] = 0;
  }
  return obj;
};

_filter = function(arr, filter) {
  var exclude;
  exclude = function(item) {
    return !(item in convertTo_Obj(filter));
  };
  return lodash.filter(arr, exclude);
};

_readDirFolderCache = (function() {
  var init, instance;
  instance = void 0;
  init = function() {
    var _deal, folders, list;
    list = fs.readdirSync(process.cwd());
    folders = [];
    _deal = function(_item, _index, _array) {
      if (isDir.sync(_item)) {
        folders.push(_item);
      }
    };
    lodash.forEach(list, _deal);
    return folders;
  };
  return {
    getInstance: function() {
      if (!instance) {
        instance = init();
      }
      return instance;
    }
  };
})();

traverse_scope = function() {
  return _filter(_readDirFolderCache.getInstance(), _options.nottraversal);
};

ignoreFilter = function() {
  return _filter(arguments[0], _options.ignore);
};

ifExistInRoot = function() {
  return lodash.includes(traverse_scope(), arguments[0]);
};

traversal_pattern = function(target) {
  var pattern;
  if (ifExistInRoot(target)) {
    pattern = '+(' + _filter(traverse_scope(), target).join('|') + ')/**/' + target;
  } else {
    pattern = '+(' + traverse_scope().join('|') + ')/**/' + target;
  }
  return pattern;
};

getFolders = function() {
  var option, target, traversal_matched;
  target = arguments[0];
  option = arguments[1];
  if (!lodash.isUndefined(option)) {
    if (lodash.isPlainObject(option)) {
      _options = lodash.merge(_default, option);
    }
  } else {
    _options = _default;
  }
  if (lodash.isString(target) && !isFile(target)) {
    traversal_matched = glob.sync(traversal_pattern(target));
    if (ifExistInRoot(target)) {
      traversal_matched.push(target);
    }
  }
  return ignoreFilter(traversal_matched);
};

FF = (function() {
  function FF(folderTarget, searchOptions) {
    this.folderTarget = folderTarget;
    this.searchOptions = searchOptions;
    return getFolders(this.folderTarget, this.searchOptions);
  }

  return FF;

})();

module.exports = FF;
